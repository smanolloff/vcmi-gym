
1. Build VCMI as per ... (link to VCMI instructions)

2. Link ai maps & config files (make them "visible" to VCMI):

    $ ln -s "$VCMI_GYM_DIR/testing/maps" "${XDG_DATA_HOME:-$HOME/.local/share}/vcmi/Maps/ai"
    $ ln -st "$HOME/.config/vcmi" "$VCMI_GYM_DIR/vcmi_gym/envs/v0/vcmi/_notes/{settings,modSettings}.json"

3. Build C++ libs: connector, loader:

    $ cd "$VCMI_GYM_DIR/envs/v0/connector"
    $ sudo apt-get install pybind11-dev
    $ cmake --fresh -S . -B build -Wno-dev \
        -D CMAKE_BUILD_TYPE=Debug \
        -D CMAKE_EXPORT_COMPILE_COMMANDS=1

    $ rm lib/*.dylib
    $ ln -s ../../vcmi/build/bin/libmyclient.so lib/
    $ cmake --build build/
    $ ln -st . build/connexport*.so

4. Python virtual env (tested with python 3.10.12):

    $ cd $VCMI_GYM_DIR
    $ sudo apt-get install python3.10-venv
    $ python3 -m venv .venv
    $ source .venv/bin/activate

    # NOTE: The virtual env is activated only for the current terminal session
    #       Activate it in the other terminal windows if needed
    #       Once activated, a `(.venv)` prefix will be shown on the prompt of the current session

    (.venv) $ sed -i 's/^tensorflow-macos/#&/' requirements.lock
    (.venv) $ pip install -r requirements.lock


5. Test installation

        $ cd "$VCMI_GYM_DIR"
        $ source .venv/bin/activate

        (.venv) $ python

        Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
        Type "help", "copyright", "credits" or "license" for more information.

        >>> import vcmi_gym  # may take some time (5-10s)
        >>> env = vcmi_gym.VcmiEnv("ai/P1.vmap")
        >>> print(env.render())  # ... render output
        >>> obs, rew, term, trunc, info = env.step(0)  # perform a "WAIT" action
        >>> print(env.render())  # ... render output

        #
        # The env's action space is not human-friendly and manual rendering after each step is annoying.
        # TestHelper is a simple and handy class to aid in manual testing:
        #

        >>> th = vcmi_gym.TestHelper(env)

        >>> th.wait()           # perform a "wait" action
        >>> th.move(1, 1)       # move to (x,y)
        >>> th.melee(5, 1, 3)   # move to (x,y) and attack at a direction 0..11 (see hexaction.h)
